# Fastbot Native 代码逻辑整理

## 一、整体架构

Fastbot Native 是一个基于强化学习的 Android UI 自动化测试框架，核心功能是根据当前 UI 状态智能选择下一个操作动作。

### 核心模块

```
native/
├── Base.h/cpp              # 基础类型和工具类
├── model/                  # 核心模型层
│   ├── Model.h/cpp        # 模型主入口，协调各组件
│   └── Graph.h/cpp        # 状态图，管理所有访问过的状态
├── agent/                  # 智能代理层
│   ├── AbstractAgent.h/cpp        # 代理基类
│   ├── AgentFactory.h/cpp          # 代理工厂
│   └── ModelReusableAgent.h/cpp    # 可重用模型代理（SARSA强化学习）
├── desc/                   # 描述层（UI元素抽象）
│   ├── Element.h/cpp       # XML元素解析
│   ├── Widget.h/cpp       # UI控件抽象
│   ├── State.h/cpp        # 页面状态抽象
│   ├── Action.h/cpp       # 操作动作抽象
│   ├── StateFactory.h/cpp # 状态工厂
│   ├── DeviceOperateWrapper.h/cpp  # 设备操作封装
│   └── reuse/              # 重用相关特殊实现
│       ├── ReuseState.h/cpp        # 重用状态（使用RichWidget）
│       ├── RichWidget.h/cpp        # 富Widget（增强Hash计算）
│       └── ActivityNameAction.h/cpp # Activity名称动作
├── events/                 # 事件和偏好设置
│   └── Preference.h/cpp   # 用户偏好配置
├── project/jni/           # JNI接口层
│   └── fastbot_native.cpp # Java调用入口
└── storage/               # 模型存储（FlatBuffers）
```

## 二、核心数据流

### 1. 主要调用流程

```
Java层调用
    ↓
JNI接口 (fastbot_native.cpp)
    ↓
Model::getOperate()  [核心入口]
    ↓
1. 解析XML → Element
    ↓
2. 创建State (StateFactory)
    ↓
3. Graph::addState() [状态去重/合并]
    ↓
4. Agent::resolveNewAction() [选择动作]
    ↓
5. Action::toOperate() [转换为设备操作]
    ↓
返回JSON格式的操作指令
```

### 2. 状态管理流程

```
XML描述 → Element → State
    ↓
State包含：
  - Activity名称
  - Widget列表（可操作的UI控件）
  - Action列表（每个Widget可执行的操作）
  - Hash值（用于状态去重）
    ↓
Graph管理：
  - 所有访问过的State（去重）
  - 已访问/未访问的Action
  - Activity访问统计
    ↓
Agent监听Graph变化，更新策略
```

## 三、核心类详解

### 1. Model（模型主控制器）

**职责：**
- 管理 Graph（状态图）
- 管理 Agent（智能代理）
- 提供 `getOperate()` 主入口

**关键方法：**
- `getOperate(xmlString, activity)` - 根据XML和Activity获取下一个操作
- `addAgent(deviceID, agentType)` - 添加代理
- `getPreference()` - 获取用户偏好设置

**工作流程：**
1. 解析XML字符串为Element对象
2. 根据Agent类型创建State
3. 将State添加到Graph（去重）
4. 通过Agent选择下一个Action
5. 将Action转换为DeviceOperateWrapper（JSON格式）

### 2. Graph（状态图）

**职责：**
- 存储所有访问过的State（使用Set去重）
- 跟踪已访问/未访问的Action
- 统计Activity访问分布
- 通知监听者（Agent）状态变化

**关键数据结构：**
- `StatePtrSet _states` - 所有状态集合
- `ActivityStateActionPtrSet _visitedActions` - 已访问动作
- `ActivityStateActionPtrSet _unvisitedActions` - 未访问动作
- `stringPtrSet _visitedActivities` - 已访问Activity集合

**关键方法：**
- `addState(state)` - 添加状态（去重，合并细节）
- `addListener(listener)` - 添加监听者（Agent）

### 3. AbstractAgent（代理基类）

**职责：**
- 根据当前State选择下一个Action
- 调整Action优先级
- 监听Graph状态变化

**状态管理：**
- `_lastState` - 上一个状态
- `_currentState` - 当前状态
- `_newState` - 新到达的状态
- `_lastAction` / `_currentAction` / `_newAction` - 对应的动作

**关键方法：**
- `resolveNewAction()` - 解析新动作（调整优先级 + 选择）
- `adjustActions()` - 调整动作优先级
- `selectNewAction()` - 选择新动作（子类实现）
- `updateStrategy()` - 更新策略（子类实现）

**优先级调整逻辑：**
- 未访问的动作：+20
- 新动作（未饱和）：+5 * 基础优先级
- 不需要目标的动作：+5（如果未访问）

### 4. ModelReusableAgent（可重用模型代理）

**职责：**
- 使用SARSA强化学习算法
- 维护重用模型（ReuseModel）
- 根据Q值选择动作

**核心算法：SARSA (State-Action-Reward-State-Action)**

**关键参数：**
- `_alpha = 0.25` - 学习率
- `_epsilon = 0.05` - 探索率（ε-greedy）
- `_gamma = 0.8` - 折扣因子
- `SarsaNStep = 5` - N步SARSA

**重用模型结构：**
```cpp
ReuseEntryIntMap _reuseModel;  // actionHash -> {activityName -> count}
ReuseEntryQValueMap _reuseQValue;  // actionHash -> QValue
```

**关键方法：**
- `selectNewAction()` - ε-greedy选择动作
- `updateStrategy()` - 更新Q值（SARSA算法）
- `computeRewardOfLatestAction()` - 计算奖励值
- `loadReuseModel()` / `saveReuseModel()` - 加载/保存模型

**奖励计算：**
- 访问新Activity的概率
- 状态动作期望值
- 考虑访问次数（sqrt归一化）

**动作选择策略：**
1. ε概率：随机选择未访问动作
2. 1-ε概率：根据Q值选择（Gumbel分布或贪心）

### 5. State（页面状态）

**职责：**
- 表示一个UI页面状态
- 包含可操作的Widget列表
- 包含Action列表

**关键属性：**
- `_activity` - Activity名称
- `_widgets` - Widget列表
- `_actions` - Action列表
- `_hashcode` - 状态哈希值（用于去重）
- `_rootBounds` - 根视图边界

**关键方法：**
- `buildFromElement()` - 从Element构建State
- `mergeWidgetAndStoreMergedOnes()` - 合并相同Widget
- `randomPickAction()` - 随机选择动作
- `greedyPickMaxQValue()` - 贪心选择最大Q值动作

**特殊实现：ReuseState**
- 继承自State
- 使用RichWidget替代普通Widget
- 增强的Hash计算，包含更多特征（动作、类名、资源ID、文本等）

### 6. Widget（UI控件）

**职责：**
- 抽象UI控件
- 支持多种操作类型（Click, LongClick, Scroll等）

**关键属性：**
- `_text` - 文本内容
- `_resourceID` - 资源ID
- `_bounds` - 控件边界
- `_actions` - 支持的操作类型集合
- `_operateMask` - 操作掩码（Enable, Clickable等）

**特殊实现：RichWidget**
- 继承自Widget
- 增强的Hash计算：
  - 包含支持的动作类型
  - 包含类名、资源ID
  - 包含自身或子控件的有效文本
  - 用于更精确的Widget识别和去重

### 7. Action（操作动作）

**职责：**
- 表示一个可执行的操作
- 包含目标Widget和操作类型

**类型：**
- `Action` - 基础动作（NOP, BACK, RESTART等）
- `ActivityStateAction` - 带状态和目标的动作

**关键属性：**
- `_actionType` - 动作类型（CLICK, LONG_CLICK, SCROLL等）
- `_target` - 目标Widget
- `_state` - 所属State
- `_qValue` - Q值（强化学习）
- `_priority` - 优先级

**关键方法：**
- `toOperate()` - 转换为设备操作（JSON格式）
- `isValid()` - 检查动作是否有效
- `isVisited()` - 检查是否已访问

### 8. Element（XML元素）

**职责：**
- 解析和表示XML UI树
- 提供XPath查询功能

**关键方法：**
- `createFromXml(xmlString)` - 从XML字符串创建
- `matchXpathSelector()` - 匹配XPath选择器
- `recursiveElements()` - 递归查找元素

### 9. Preference（用户偏好）

**职责：**
- 加载用户配置文件
- 提供自定义动作
- 资源ID映射
- 黑名单Widget过滤
- 树剪枝

**配置文件：**
- `/sdcard/max.config` - 基础配置
- `/sdcard/max.xpath.actions` - 自定义动作
- `/sdcard/max.widget.black` - 黑名单Widget
- `/sdcard/max.tree.pruning` - 树剪枝规则
- `/sdcard/max.mapping` - 资源ID映射

**关键方法：**
- `resolvePageAndGetSpecifiedAction()` - 解析页面并获取指定动作
- `patchOperate()` - 修补操作（如文本模糊测试）
- `checkPointIsInBlackRects()` - 检查点是否在黑名单区域

## 四、强化学习算法

### SARSA算法实现

**核心思想：**
使用N步SARSA算法，通过Q值学习最优策略。

**更新公式：**
```
Q(s,a) = Q(s,a) + α * [R + γ * Q(s',a') - Q(s,a)]
```

**实现细节：**
1. **奖励计算：**
   - 访问新Activity的概率
   - 状态动作期望值
   - 归一化：`reward / sqrt(visitCount + 1)`

2. **Q值更新：**
   - 使用N步累积奖励
   - 只更新最旧的动作（i==0）
   - 其他步骤只累积奖励

3. **动作选择：**
   - ε-greedy策略
   - 或使用Gumbel分布（humble-gumbel）

4. **模型持久化：**
   - 使用FlatBuffers序列化
   - 后台线程定期保存

## 五、状态去重机制

### Hash计算

**State Hash：**
- 基于Activity名称
- 基于Widget列表（合并相同Widget）
- 可选：包含文本、索引、顺序

**Action Hash：**
- 基于Action类型
- 基于目标Widget的Hash
- 基于所属State的Hash

### 去重策略

1. **State去重：**
   - Graph使用Set存储State
   - 相同Hash的State会被合并
   - 新State的细节会填充到已存在的State

2. **Action去重：**
   - Graph维护已访问/未访问Action集合
   - 相同Hash的Action共享ID和访问状态

## 六、JNI接口

### 主要接口

1. **`Java_com_bytedance_fastbot_AiClient_b0bhkadf`** (getAction)
   - 输入：Activity名称、XML描述
   - 输出：JSON格式的操作指令

2. **`Java_com_bytedance_fastbot_AiClient_fgdsaf5d`** (InitAgent)
   - 初始化Agent
   - 加载重用模型

3. **`Java_com_bytedance_fastbot_AiClient_jdasdbil`** (loadResMapping)
   - 加载资源ID映射

4. **`Java_com_bytedance_fastbot_AiClient_nkksdhdk`** (checkPoint)
   - 检查点是否在黑名单区域

## 七、关键设计模式

1. **工厂模式：**
   - `AgentFactory` - 创建不同类型的Agent
   - `StateFactory` - 创建不同类型的State

2. **观察者模式：**
   - `GraphListener` - Graph通知Agent状态变化

3. **策略模式：**
   - `AbstractAgent` - 不同算法实现不同策略

4. **单例模式：**
   - `Preference::inst()` - 全局唯一配置实例

## 八、性能优化

1. **状态去重：**
   - 使用Hash快速查找
   - 合并相同状态，节省内存

2. **细节清理：**
   - `DROP_DETAIL_AFTER_SATE` - 状态Hash后清理细节
   - 减少内存占用

3. **模型持久化：**
   - 后台线程异步保存
   - 使用FlatBuffers高效序列化

4. **优先级调整：**
   - 预计算优先级，避免重复计算

## 九、配置参数

### 编译时配置（utils.hpp）

- `DROP_DETAIL_AFTER_SATE` - Hash后是否清理细节
- `STATE_WITH_TEXT` - Hash是否包含文本
- `STATE_TEXT_MAX_LEN` - 文本最大长度（6，2个中文字符）
- `STATE_WITH_INDEX` - Hash是否包含索引
- `STATE_WITH_WIDGET_ORDER` - Hash是否考虑Widget顺序
- `BLOCK_STATE_TIME_RESTART` - 阻塞状态重启阈值

### 运行时配置（Preference）

- 自定义动作
- 黑名单Widget
- 树剪枝规则
- 资源ID映射
- 输入文本列表

## 十、总结

Fastbot Native 是一个基于强化学习的智能UI测试框架，核心特点：

1. **状态图管理：** 维护所有访问过的UI状态，实现状态去重和复用
2. **强化学习：** 使用SARSA算法学习最优测试策略
3. **模型持久化：** 重用模型可以保存和加载，实现跨会话学习
4. **灵活配置：** 支持用户自定义动作、黑名单、树剪枝等
5. **高效实现：** 使用Hash去重、细节清理等优化手段

整体架构清晰，模块职责明确，是一个设计良好的自动化测试框架。
